/* Copyright (c) 2006, NIF File Format Library and Tools
All rights reserved.  Please see niflib.h for licence. */

#ifndef _NITRIBASEDGEOM_H_
#define _NITRIBASEDGEOM_H_

#include "NiGeometry.h"

// Include structures
#include "../Ref.h"
namespace Niflib {

// Forward define of referenced NIF objects

//#include "../gen/obj_defines.h"

class NiTriBasedGeom;
typedef Ref<NiTriBasedGeom> NiTriBasedGeomRef;

/*!
 * NiTriBasedGeom - Describes a mesh, built from triangles.
 */

class NiTriBasedGeom : public NI_TRI_BASED_GEOM_PARENT {
public:
	NIFLIB_API NiTriBasedGeom();
	NIFLIB_API ~NiTriBasedGeom();
	//Run-Time Type Information
	NIFLIB_API static const Type TYPE;
	NIFLIB_API static NiObject * Create();
	NIFLIB_API virtual const Type & GetType() const;
	NIFLIB_HIDDEN virtual void Read( istream& in, list<unsigned int> & link_stack, const NifInfo & info );
	NIFLIB_HIDDEN virtual void Write( ostream& out, const map<NiObjectRef,unsigned int> & link_map, const NifInfo & info ) const;
	NIFLIB_API virtual string asString( bool verbose = false ) const;
	NIFLIB_HIDDEN virtual void FixLinks( const map<unsigned int,NiObjectRef> & objects, list<unsigned int> & link_stack, const NifInfo & info );
	NIFLIB_HIDDEN virtual list<NiObjectRef> GetRefs() const;

	/*!
	 * This generates skin data for hardware acceleration.  Specifically, it creates a NiSkinPartition object based on the current skin weights.  This splits up the mesh into smaller parts that are affected by fewer bones so that they can be processed by 3D accelerator hardware.
	 * \param[in] max_bones_per_partition The maximum number of bones that can affect a skin partition, i.e. a sub-mesh generated by chopping up the original mesh.  Proper value is game dependent.
	 * \param[in] max_bones_per_vertex The maximum number of bones that can affect any one vertex.  Vertices affected by more bones than this will have the bone witht he smallest affect removed and the remaining bones will be normalized.
	 */
	NIFLIB_API void GenHardwareSkinInfo( int max_bones_per_partition = 4, int max_bones_per_vertex = 4 );

	/*!
	 * This clears any hardware acceleration skin data that was previously created.
	 */
	NIFLIB_API void ClearHardareSkinInfo();

	/*!
	 * Generate or update a NiStringExtraData object with precalculated
	 * tangent and binormal data (Oblivion specific)
	 */
	NIFLIB_API void UpdateTangentSpace();

protected:
	NI_TRI_BASED_GEOM_MEMBERS
private:
	void InternalRead( istream& in, list<unsigned int> & link_stack, const NifInfo & info );
	void InternalWrite( ostream& out, const map<NiObjectRef,unsigned int> & link_map, const NifInfo & info ) const;
	string InternalAsString( bool verbose ) const;
	void InternalFixLinks( const map<unsigned int,NiObjectRef> & objects, list<unsigned int> & link_stack, const NifInfo & info );
	list<NiObjectRef> InternalGetRefs() const;
};

}
#endif
